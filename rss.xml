<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>FrankWkd&apos;s Blog</title><description>My Development Workstation</description><link>https://github.com/FrankWkd-Pro/Firefly/</link><language>zh_CN</language><item><title>我的博客搬家啦</title><link>https://github.com/posts/20251018aboutme/</link><guid isPermaLink="true">https://github.com/posts/20251018aboutme/</guid><description>焕然一新的交互式博客，Firefly主题，高速渲染~</description><pubDate>Sat, 18 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;欢迎来到我的新博客！&lt;/h2&gt;
&lt;p&gt;经过一段时间的筹备和设计，我终于将我的博客搬到了一个全新的平台，并采用了 Firefly 主题。这个新博客不仅在视觉上焕然一新，还提供了更好的交互体验和更快的内容渲染速度。&lt;br /&gt;
&lt;strong&gt;旧博客中的博文并没有迁移，请到旧博客查看：&lt;a href=&quot;https://blog.frankwkd.vvvv.host&quot;&gt;FrankWkd&apos;s Blog(Butterfly)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;关于我&lt;/h3&gt;
&lt;p&gt;我是 FrankWkd ，一个在数字世界中默默无闻的一片叶子，爱好探索与实践。&lt;br /&gt;
坐标： Jilin, China.&lt;br /&gt;
身份：Developer &amp;amp; Student. &lt;strong&gt;[Not accepting employment]&lt;/strong&gt;&lt;br /&gt;
了解更多：&lt;br /&gt;
- &lt;strong&gt;前往：&lt;/strong&gt; &amp;lt;a href=&quot;/skills/&quot;&amp;gt;我的技能&amp;lt;/a&amp;gt;&lt;br /&gt;
- &lt;strong&gt;前往：&lt;/strong&gt; &amp;lt;a href=&quot;/projects/&quot;&amp;gt;我的项目&amp;lt;/a&amp;gt;
&lt;img src=&quot;https://frankwkd-pro.pages.dev/profile-3d-contrib/profile-night-rainbow.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;与我联系&lt;/h3&gt;
&lt;p&gt;如果你想和我交流技术问题，分享有趣的想法，或者只是想打个招呼，欢迎通过以下方式联系我：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;邮箱&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;mailto:frankwkd@outlook.com&quot;&gt;FrankWkd@outlook.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;mailto:frankwkd-plus@outlook.com&quot;&gt;FrankWkd-Plus@outlook.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Github&lt;/strong&gt;: 欢迎大家 Follow 我在 GitHub 上的项目和动态~
&lt;ul&gt;
&lt;li&gt;如果想看看我的其他项目或私信我，可以访问我的 &lt;a href=&quot;https://github.com/FrankWkd-Pro&quot;&gt;GitHub 主页&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你想对我的博客反馈问题，可以在我的博客仓库中提交 issue: &lt;a href=&quot;https://github.com/FrankWkd-Pro/Firefly&quot;&gt;Firefly 仓库&lt;/a&gt;:&lt;/li&gt;
&lt;li&gt;::github{repo=&quot;FrankWkd-Pro/Firefly&quot;}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果你想和我交流算法，C++之类的问题，可以在洛谷或者 Codeforces 私信我，我会优先回复。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;洛谷&lt;/strong&gt;: &lt;a href=&quot;https://www.luogu.com.cn/user/845400&quot;&gt;FrankWkd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Codeforces&lt;/strong&gt;: &lt;a href=&quot;https://codeforces.com/profile/FrankWkd&quot;&gt;FrankWkd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;关于 Firefly&lt;/h3&gt;
&lt;p&gt;基于 Astro 框架构建的功能丰富的个人博客系统，具有以下特色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;🎭 &lt;strong&gt;双引擎看板娘&lt;/strong&gt;: 支持Spine和Live2D双引擎，集成可爱的动画模型，支持交互和拖拽&lt;/li&gt;
&lt;li&gt;📺 &lt;strong&gt;Bangumi追番&lt;/strong&gt;: 集成Bangumi API，自动同步追番列表，支持多状态筛选和分页浏览&lt;/li&gt;
&lt;li&gt;🌙 &lt;strong&gt;智能主题&lt;/strong&gt;: 支持亮色/暗色主题自动切换，可自定义主题色相&lt;/li&gt;
&lt;li&gt;📱 &lt;strong&gt;响应式设计&lt;/strong&gt;: 完美适配各种设备，移动端优化体验&lt;/li&gt;
&lt;li&gt;⚡ &lt;strong&gt;性能优化&lt;/strong&gt;: 静态站点生成，超快加载速度&lt;/li&gt;
&lt;li&gt;🎨 &lt;strong&gt;动态背景&lt;/strong&gt;: 支持Banner和全屏覆盖两种壁纸模式，可配置位置和效果&lt;/li&gt;
&lt;li&gt;🌸 &lt;strong&gt;特效系统&lt;/strong&gt;: 内置樱花飘落特效，可自定义数量、速度和大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感谢你的来访！希望在这里能找到对你有用的内容。如果喜欢的话，不妨在 &lt;a href=&quot;https://github.com/FrankWkd-Pro/Firefly&quot;&gt;Github&lt;/a&gt; 点个Star ⭐ 支持一下:&lt;br /&gt;
::github{repo=&quot;FrankWkd-Pro/Firefly&quot;}&lt;/p&gt;
</content:encoded></item><item><title>贪心算法总结</title><link>https://github.com/posts/20251019greedy-summary/</link><guid isPermaLink="true">https://github.com/posts/20251019greedy-summary/</guid><pubDate>Sun, 19 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1 用两个元素的交换来推出贪心方法（邻项交换法）&lt;/h2&gt;
&lt;p&gt;这个方法适用于解决顺序问题或者安排问题，通过先解决小问题来总结出规律，从而解决出这个题目。&lt;/p&gt;
&lt;h3&gt;例题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1080&quot;&gt;P1080 [NOIP 2012 提高组] 国王游戏&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个题目就是典型的邻项交换法推贪心。&lt;/p&gt;
&lt;h4&gt;1. 假设&lt;/h4&gt;
&lt;p&gt;我们先假设国王后面只有两个大臣，而且假设国王拿着的是 $a_0,b_0$，第一个大臣拿的是 $a_1,b_1$，第二个大臣拿的是 $a_2,b_2$，我们有两种顺序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个大臣在前面，那么第一个大臣得到的奖金就是 $\frac{a_0}{b_1}$，第二个大臣拿到的奖金就是 $\frac{a_0\times a_1}{b_2}$，最高的奖赏就是 $\max{(\frac{a_0}{b_1},\frac{a_0\times a_1}{b_2})}$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个大臣在前面，那么第二个大臣得到的奖金就是 $\frac{a_0}{b_2}$，第一个大臣拿到的奖金就是 $\frac{a_0\times a_2}{b_1}$，最高的奖赏就是 $\max{(\frac{a_0}{b_2},\frac{a_0\times a_2}{b_1})}$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 推导&lt;/h4&gt;
&lt;p&gt;现在我们就要来比较最高的奖赏，即比较 $\max{(\frac{a_0}{b_2},\frac{a_0\times a_2}{b_1})}$ 和 $\max{(\frac{a_0}{b_1},\frac{a_0\times a_1}{b_2})}$ 谁更小。&lt;/p&gt;
&lt;p&gt;我们发现 $\frac{a_0}{b_1}$ 一定小于等于 $\frac{a_0\times a_2}{b_1}$（因为 $a_2$ 是大于 0 的整数，即 $a_2 \ge 1$，不会变小），同理 $\frac{a_0}{b_2}$ 一定小于等于 $\frac{a_0\times a_1}{b_2}$。所以我们可以将式 $[a]$ 转化为求
$$\min{(\frac{a_0\times a_1}{b_2},\frac{a_0\times a_2}{b_1})[a]}$$
的答案。&lt;/p&gt;
&lt;p&gt;我们把 $\frac{a_0\times a_1}{b_2}$ 和 $\frac{a_0\times a_2}{b_1}$ 同时除 $a_0$，在乘上 $b_1\times b_2$，就把这两个式子化简为 $b_1\times a_1$ 和 $b_2\times a_2$。发现什么没有？我们把结果的大小比较转化为了大臣手上数的乘积比较，如果 $a_1\times b_1$ 小于 $a_2\times b_2$，那么就把 1 号大臣排在前面，否则排在后面。&lt;/p&gt;
&lt;h3&gt;例题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1248&quot;&gt;P1248 加工生产调度&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;1. 假设&lt;/h4&gt;
&lt;p&gt;我们假设有两个产品 $x$ 和 $y$，$x$ 产品在 A 车间加工时间是 $a_x$，同理，其他的分别为 $b_x$、$a_y$、$b_y$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$x$ 产品先做，那么 $x$ 产品所有的时间就是 $a_x+b_x$，由于 $y$ 产品要等到 $x$ 产品加工完才行，那么 $y$ 产品在 A 车间加工就需要 $a_x+a_y$ 的时间（$a_x$ 的等待时间），而此时 $x$ 产品在 B 车间加工了 $a_y$ 的时间，还需要 $\max{(b_x-a_y,0)}$ 的时间加工，所以 $y$ 产品在 B 车间需要 $\max{(b_x-a_y,0)}+b_y$ 的时间加工。由于 $y$ 产品肯定是等到 $x$ 产品加工后才结束，所以花费的总时间是 $a_x+a_y+\max{(b_x-a_y,0)}+b_y$ 的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同理 $y$ 产品先做就需要花费 $a_x+a_y+\max{(b_y-a_x,0)}+b_x$ 的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 推导&lt;/h4&gt;
&lt;p&gt;现在我们需要比较 $x$ 产品先做和 $y$ 产品先做的时间，即求出
$$\min(a_x+a_y+\max(b_x-a_y,0)+b_y,a_x+a_y+\max(b_y-a_x,0)+b_x)[b]$$&lt;/p&gt;
&lt;p&gt;不难发现 $x\pm \max(a,b)=\max(x\pm a,x\pm b)$，对于 $\min$ 也成立，所以 $[b]$ 式就可以化简为：&lt;/p&gt;
&lt;p&gt;$$\min(a_x+a_y+\max(b_x,a_y)-a_y+b_y,a_x+a_y+\max(b_y,a_x)-a_x+b_x)$$&lt;/p&gt;
&lt;p&gt;$$=\min(a_x+b_y+\max(b_x,a_y),a_y+b_x+\max(b_y,a_x))$$&lt;/p&gt;
&lt;p&gt;$$=\min(\max(b_x,a_y)-a_y-b_x,\max(b_y,a_x)-a_x-b_y)+a_x+a_y+b_x+b_y$$&lt;/p&gt;
&lt;p&gt;$$=\min(\max(-a_y,-b_x),\max(-a_x,-b_y))+a_x+a_y+b_x+b_y$$&lt;/p&gt;
&lt;p&gt;至于继续的推导，需要用到 Johnson 定理，感兴趣的读者可以自己去了解一下。&lt;/p&gt;
&lt;p&gt;最终的排序方法是将 $\min(a_x,a_y) &amp;lt; \min(b_x,b_y)$ 的 $x$ 排前面。&lt;/p&gt;
&lt;h3&gt;例题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1842&quot;&gt;P1842 奶牛玩杂技&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;1. 假设&lt;/h4&gt;
&lt;p&gt;假设有两头牛 $a$ 和 $b$，那么它们的体重分别是 $w_a$ 和 $w_b$，力量是 $s_a$ 和 $s_b$。&lt;/p&gt;
&lt;p&gt;如果现在只有这两头牛，那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$a$ 在上面，那么 $a$ 的压扁指数为 $-s_a$，$b$ 的压扁指数为 $w_a-s_b$，总压扁指数为 $\max(-s_a,w_a-s_b)$。（注意这里不能直接省去 $-s_a$，虽然它为负数，但当 $w_a-s_b&amp;lt;-s_a$ 时就会取 $-s_a$。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$b$ 在上面，那么同理，总压扁指数为 $\max(-s_b,w_b-s_a$)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 进一步的假设&lt;/h4&gt;
&lt;p&gt;如果我们要使 $a$ 在上面，那么我们该怎么做呢？&lt;/p&gt;
&lt;p&gt;我们需要满足 $\max(-s_a,w_a-s_b) &amp;lt; \max(-s_b,w_b-s_a)$。&lt;/p&gt;
&lt;p&gt;易证 $-s_a &amp;lt; w_b-s_a,-s_b &amp;lt; w_a-s_b$ 所以 $\max(-s_a,w_a-s_b)$ 就可以变为 $w_a-s_b$，同理 $\max(-s_b,w_b-s_a)$ 变为 $w_b-s_a$。&lt;/p&gt;
&lt;p&gt;因为我们要使 $w_a-s_b &amp;lt; w_b-s_a$，简单移项便可以得到 $w_a+s_a&amp;lt;w_b+s_b$。&lt;/p&gt;
&lt;p&gt;所以如果要使 $a$ 在上面，必须要 $w_a+s_a&amp;lt;w_b+s_b$。&lt;/p&gt;
&lt;h2&gt;2 区间类贪心（区间类问题）&lt;/h2&gt;
&lt;p&gt;这个方法适用于一系列的区间取舍问题，最基础的问题有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;区间选点（在 $n$ 个区间放尽量少的点，使得每个区间都有点）&lt;/li&gt;
&lt;li&gt;区间覆盖（选择尽量少的区间覆盖整个线段）&lt;/li&gt;
&lt;li&gt;区间分组（将区间分成尽量少的组使得组内的区间两两互不相交）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;区间类问题的常用方法是按右端点排序，方便解决区间取舍后对下一个区间的影响（如果不按右端点排序就有后效性了，不能用贪心解决）。&lt;/p&gt;
&lt;h3&gt;例题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P2255&quot;&gt;P2255 [USACO14JAN] Recording the Moolympics S&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;同样，我们先按右端点排序，然后因为有两个节目可以同时录制，我们用 $p_1$ 和 $p_2$ 来代表两个节目的结束时间。&lt;/p&gt;
&lt;p&gt;贪心策略：由于靠前的节目是结束时间更小的，所以结束后可以更快安排下一个节目，所以我们只需要按右端点排序后挨个判断节目是否可以即可。&lt;/p&gt;
&lt;h3&gt;例题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P11232&quot;&gt;P11232 [CSP-S 2024] 超速检测&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本题的前一部分求超速区间这里不再细讲了。&lt;/p&gt;
&lt;p&gt;对于每一个区间 $[l_1,r_1]$，如果另一个区间 $[l_2,r_2]$ 使得 $l_2 \le l_1 \le r_1 \le r_2$，也就是区间 $[l_1,r_1]$ 被包含在了 $[l_2,r_2]$ 里，那么显然满足了 $[l_1,r_1]$ 就一定满足 $[l_2,r_2]$，且根据贪心策略，满足 $[l_1,r_1]$ 是最优的。&lt;/p&gt;
&lt;p&gt;所以我们按左端点排序，找到下标 $x,y$ 满足 $r_x &amp;gt; r_y$，那么将 $r_y$ 删除，最后剩下的区间是一定不会两两重叠的。&lt;/p&gt;
&lt;p&gt;最后按普通的贪心（用 lower_bound 找离区间右端点最近的摄像头是最优的）即可完成。&lt;/p&gt;
&lt;p&gt;注意精度误差带来的影响。&lt;/p&gt;
&lt;h2&gt;3 数据结构优化贪心——并查集&lt;/h2&gt;
&lt;p&gt;在有些时候，贪心的复杂度为 $n^2$，其中一个 $n$ 的复杂度是寻找前面&lt;strong&gt;满足条件&lt;/strong&gt;的元素所需的复杂度，所以我们可以用并查集优化。&lt;/p&gt;
&lt;h3&gt;例题：&lt;a href=&quot;https://www.luogu.com.cn/problem/U213773&quot;&gt;U213773 家庭作业&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我们很容易推出贪心策略：先选得分大的，如果这个作业有时间就做，没时间直接舍去，但由于每次查找之前的时间都需要 $n$，总复杂度为 $n^2$，考虑并查集优化。&lt;/p&gt;
&lt;p&gt;我们定义 $f_i$ 为 $i$ 天前的&lt;strong&gt;第一个&lt;/strong&gt;空闲时间，那么查找这个作业是否可以就是 $find(x)$，复杂度为 $1$（路径压缩）。&lt;/p&gt;
&lt;h3&gt;例题：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1525&quot;&gt;P1525 [NOIP 2010 提高组] 关押罪犯&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;很明显，我们需要让危害性较大的两个罪犯分到两个监狱里。我们用 $f_i$ 表示第 $i$ 个人和 $f_i$ 个人放在一个监狱里，$b_i$ 表示跟 $i$ 仇恨度最大的人是谁。&lt;/p&gt;
&lt;p&gt;很明显，如果现在 $b_x$ 已经有值了，所以为了他们并不互相冲突，只能将 $b_x$ 和 $y$ 放在一个监狱里面，如果没有 $b_x$，根据贪心策略，肯定将 $x$ 和 $y$ 放在两个监狱里。&lt;/p&gt;
&lt;h2&gt;4 数据结构优化贪心——优先队列&lt;/h2&gt;
&lt;p&gt;贪心中查找最大或最小值&lt;strong&gt;且两个元素在同一位置的查找范围一样&lt;/strong&gt;，那么就可以用 $\log n$ 的复杂度取代 $n$ 的暴力枚举。&lt;/p&gt;
&lt;h3&gt;例题：&lt;a href=&quot;https://www.luogu.com.cn/problem/AT_abc407_e&quot;&gt;[ABC407E] Most Valuable Parentheses&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;很明显，我们只要满足左括号的数量等于右括号的数量且在任何一个 $1\sim i$ 的序列中的左括号都要大于右括号，所以我们只需要在前 $i \times 2 - 1$ 个当中选择 $i$ 个，可以证明保证从 $2\times x - 1$ 到 $2 \times (x + 1) - 1$ 会同时增加一个左括号和右括号。&lt;/p&gt;
&lt;p&gt;所以我们可以用优先队列，从 $1$ 枚举到 $2\times n$，每次枚举到奇数位就将序列中最大的元素累加答案。&lt;/p&gt;
</content:encoded></item></channel></rss>